#include <cstdio>
#include <cstring>
#include <queue>
#include <algorithm>

const int N = 2e5 + 1e4;
const int M = 4e5 + 1e4;
const int INF = 0x3f3f3f3f;
const long long LONG_INF = 1 << 62;

int T;
int n, m, u, v, l, a;

struct node{
	int now, val;
	bool operator< (node b){
		return this -> val < b.val;
	}
}tmp;

class kruskal_tree{
	public:
		int ecnt;
		struct uds{
			int fa[N << 1];
			void init(int n){n <<= 1; for(int i = 1; i <= n; i++) fa[i] = i;}
			void get_fa(int now){return fa[now] == now? now: fa[now] = get_fa(fa[now]);}
			int& operator[](int now){ return fa[now]; }	
		}set;
		struct edge_normal{
			int now, to, val, hei;	
			bool operator<(edge_normal b){
				return this -> hei > b.hei;
			}
		}e[M << 1];
		class Graph{
			public:
				int n, dis[N];
				bool vis[N];
				struct node{
					int dep, val;
					int fa[20];
				}nodes[N << 1];
				struct edge{
					int next, to, val;
				}e[M << 1];
				int ehead[N << 1], ecnt;
				inline void add_edge(int now, int to, int val = 0);
				inline void dijrstra();
				inline void init();	
				void get_st(int now, int fa, int dep = 1);
		}G;
		inline void add_edge(int now, int to, int val, int hei);
		inline void get_pre(int n);
		inline void init();
		inline void build_tree(int n);
}Tree;

void kruskal_tree::Graph::get_st(int now, int fa, int dep){
	nodes[i].fa[0] = fa; nodes[i].dep = dep;
	if(now >= 1 && now <= n)
		nodes[now].min = nodes[now].dis, nodes[now].min = INF;
	else 
		nodes[now].min = LONG_INF;
	for(int i = 1; i <= log2[dep]; k++){
		nodes[i].fa[k] = nodes[ nodes[i].fa[k - 1] ].fa[k - 1];
	}
	for(int i = ehead[now]; i; i = e[i].next){
		dfs(e[i].to, now, dep + 1);
		nodes[now].min = Min(nodes[now].min, nodes[ e[i].to ].min);
	}
}

void kruskal_tree::Graph::dijrstra(){
	while( !q.empty() ) q.pop();
	memset(dis, 0x3f, sizeof(dis));	
	memset(vis, false, sizeof(vis));
	dis[1] = 0;q.push( (node){1, 0} );
	while( !q.empty() ){
		tmp = q.top();	
		q.pop();
		if( vis[ tmp.now ] )
			continue;
		vis[ tmp.now ] = true;
		for(int i = ehead[now]; i; i = e[i].next){
			if(dis[ e[i].to ] > dis[now] + e[i].val){
				dis[ e[i].to ] = dis[now] + e[i].val;
				if( vis[ e[i].to ] == false )
					q.push( (node){e[i].to, dis[ e[i].to ]} );
			}	
		}
	}
}

inline void kruskal_tree::Graph::init(){
	ecnt = 0;
	memset(ehead, 0, sizeof(ehead));
}

inline void kruskal_tree::init(){
	ecnt = 0;
	G.init();
}

inline void kruskal_tree::Graph::add_edge(int now, int to, int val){
	ecnt++;
	e[ecnt].to = to;
	e[ecnt].next = ehead[now];
	e[ecnt].val = val;
	ehead[now] = ecnt;
}

inline void kruskal_tree::add_edge(int now, int to, int val, int hei){ e[++ecnt] = (edge_normal){now, to, val, hei}; }

inline void kruskal_tree::build_tree(int n){
	G.init(); set.init();
	G.n = n;
	std::sort(e + 1, e + ecnt + 1);
	for(int i = 1; i <= n; i++){
		int tmp_x = get_fa( e[i].now ), tmp_y = get_fa( e[i].to );		
		if(tmp_x != tmp_y){
			G.n++;
			G.add_edge(G.n, tmp_x);
			G.add_edge(G.n, tmp_y);
			G.nodes[ G.n ].val = e[i].hei;
			set[tmp_x] = G.n;
			set[tmp_y] = G.n;
		}
	}
	G.dijrstra();
}

inline void kruskal_tree::get_pre(int n){
	build_tree();	
	G.get_st(G.n, 0);
}

inline void init(){
	Tree.init();
}

void readin(){
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= m; i++){
		scanf("%d%d%d%d", &u, &v, &l ,&a);	
		Tree.add_edge(u, v, l, a);
		Tree.G.add_edge(u, v, l);
	}
}


int main(){
#ifdef woshiluo
	freopen("luogu.5109.in", "r", stdin);
	freopen("luogu.5109.out", "w", stdout);
#endif
#ifndef woshiluo
	freopen("return.in", "r" , stdin);
	freopen("return.out", "w", stdout);
#endif	
	scanf("%d", &T);
	while(T--){
		init();		
		readin();
		Tree.get_pre(n);
	}
}
