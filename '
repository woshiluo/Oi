#include <cstdio>
#include <cstring>
#include <algorithm>

const int N = 11000;
const int M = 51000;

int n, m, x, y, z;

class kruskal_tree{
	public:
		int ecnt_normal;
		struct edge_normal{
			int now, to, val;
			bool operator < (edge_normal &b) const{
				return this -> val < b.val;	
			}
		}e_normal[M << 1];
		struct uds{
			int fa[N];
			inline void init(int n){for(int i = 0; i <= n; i++) fa[i] = i;}
			int& operator[](int now){return fa[now];}
			inline int get_fa(int now){return fa[now] == now ? now: fa[now] = get_fa(fa[now]);};
		}set; 
		class Graph{	
			public:
				int ecnt, ehead[N];
				struct node{
					int val, son, mson, top, id, dep, fa;
				}nodes[N << 1];
				struct edge{
					int now, to, next;
				}e[M << 1];
				class HLD{
					public:
						int idcnt;
						void find_son(int now);
						void get_edges(int now, int dep);  
						void init(int now);
				}hld;
				inline void add_edge(int now, int to);
		}G;
		inline void add_edge_normal(int now, int to, int val);
		inline void build_tree(int &n);
		inline void init(int n);
}T;

void kruskal_tree::Graph :: find_son(int now){
	Graph::nodes[now].son = 1;
	Graph::nodes[now].mson = 0;
	for(int i = Graph::ehead[now]; i; i = Graph::e[i].next){
		find_son(e[i].to);	
		Graph::nodes[now].son += Graph::nodes[now].son;
		if(Graph::nodes[ Graph::e[i].to ].son > Graph::nodes[ nodes[now].mson ].son)
			Graph::nodes[now].mson = e[i].to;
	}	
}

void kruskal_tree::Graph::get_edges(int now, int dep){
	Graph::nodes[now].id = ++idcnt;
	Graph::nodes[now].dep = dep;
	if(Graph::nodes[now].top == 0) Graph::nodes[now].top = now;
	if(Graph::nodes[now].mson == 0) return ;			
	Graph::nodes[ Graph::nodes[now].mson ].top = Graph::nodes[now].top;
	get_edges(Graph::nodes[now].mson, dep + 1);
	for(int i = Graph::ehead[now]; i; i = Graph::e[i].next){
		if(Graph::e[i].to == Graph::nodes[now].mson) 
			continue;
		Graph::nodes[ Graph::e[i].to ].fa = now;
		get_edges(Graph::e[i].to, dep + 1);
	}
}

void kruskal_tree::Graph::init(int now){
	nodes[0].son = -1;
	idcnt = 0;
	find_son(now);
	get_edges(now, 1);
}

inline void kruskal_tree::add_edge_normal(int now, int to, int val){
	ecnt_normal++;
	e_normal[ecnt_normal].now = now;
	e_normal[ecnt_normal].to = to;
	e_normal[ecnt_normal].val = val;
}

inline void kruskal_tree::Graph::add_edge(int now, int to){
	ecnt++;
	e[ecnt].to = to;
	e[ecnt].next = ehead[now];
	ehead[now] = ecnt;
}


inline void kruskal_tree::build_tree(int &n){
	int tmp_cnt = n;
	set.init(n);
	std::sort(e_normal + 1, e_normal + ecnt_normal + 1);
	for(int i = 1; i <= ecnt_normal; i++){
		if(tmp_cnt >= n) break;
		int tmp_x = set.get_fa(e_normal[i].now), tmp_y = set.get_fa(e_normal[i].to);
		if(tmp_x != tmp_y){
			tmp_cnt++;		
			G.nodes[tmp_cnt].val = e_normal[i].val;
			G.add_edge(tmp_cnt, tmp_y);
			G.add_edge(tmp_cnt, tmp_x);
			set[tmp_x] = tmp_cnt;
			set[tmp_y] = tmp_cnt;
		}
	}
	n = tmp_cnt;
}

inline void kruskal_tree::init(int n){
	build_tree(n);
	G.hld.init(n);
}

int main(){
	scanf("%d%d", &n, &m);	
	for(int i = 1; i <= n; i++){
		scanf("%d%d%d", &x, &y, &z);					
		T.add_edge_normal(x, y, z);
		//T.add_edge_normal(y, x, z);
	}
	T.init(n);
}
