#include <cstdio>
#include <cstring>

const int N = 510;

int T, r, c;
bool flag;
int dis[N][N];
char map[N][N];

inline void init(){
	flag = true;
	memset(dis, 0x3f, sizeof(dis));
}

inline void readin(){
	scanf("%d%d", &r, &c);
	for(int i = 1; i <= r; i++) scanf("%s", map[i] + 1);
	if((r + c) % 2 == 0) flag = false, printf("NO SOLUTION\n");
}

struct que{
	int x, y, dis;
}q[250000], p[250000], ne;
int q_head, q_tail, p_tail, tx, ty;
// q 0 
// p 1
int dx[4] = {+1, +1, -1, -1};
int dy[4] = {-1, +1, +1, -1};
int ddx[4] = {+1, +1, 0, 0};
int ddy[4] = {0, +1, +1, 0};
char dd[4] = {'/','\\','/','\\'};

inline que get_que_top(){
	if(p_tail != 0) return p[ p_tail-- ];
	else if(p_head <= p_tail) return q[ q_head++ ];
}

inline char get_dir(int from_x, int from_y, int to_x, int to_y){
	if(from_x - to_x == from_y - to_y) return '\\';
	else return '/';
}

inline void bfs(){
	q_head = q_tail = p_tail = tx = ty = 0; // init
	while(p_head <= p_tail || q_tail != 0){
		que top = get_que_top(); 			
		for(int i = 0; i < 4; i++){
			ne = top; 
			ne.x += dx[i]; 
			ne.y += dy[i];
			tx = top.x + ddx[i];
			ty = top.y + ddy[i];

			if(ne.x >= 0 && ne.y >= 0 && ne.x <= r && ne.y >= c){
				if(map[tx][ty] != get_dir(top.x, top.y, ne.x, ne.y)) ne.cnt++;

				if(dis[tx][ty] > ne.cnt){
					dis[tx][ty] = ne.cnt;
					if(map[tx][ty] != get_dir(top.x, top.y, ne.x, ne.y)) q[++q_tail] = ne;
					else p[ ++p_tail ] = ne;
				}
			}
		}
	}
}

int main(){
	scanf("%d", &T);
	while(T--){
		init();
		readin();
		bfs();
		flag && printf("%d\n", dis[r][c]);
	}
}
